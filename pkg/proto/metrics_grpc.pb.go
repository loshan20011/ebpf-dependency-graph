// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: pkg/proto/metrics.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MetricsStreamClient is the client API for MetricsStream service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MetricsStreamClient interface {
	// StreamLatencyMetrics streams latency measurements (client-side streaming)
	StreamLatencyMetrics(ctx context.Context, opts ...grpc.CallOption) (MetricsStream_StreamLatencyMetricsClient, error)
	// StreamConnectionEvents streams connection establishment events (client-side streaming)
	StreamConnectionEvents(ctx context.Context, opts ...grpc.CallOption) (MetricsStream_StreamConnectionEventsClient, error)
	// StreamFlowEvents streams network flow events for dependency tracking
	StreamFlowEvents(ctx context.Context, opts ...grpc.CallOption) (MetricsStream_StreamFlowEventsClient, error)
	// StreamDependencyEvents streams dependency relationship changes
	StreamDependencyEvents(ctx context.Context, opts ...grpc.CallOption) (MetricsStream_StreamDependencyEventsClient, error)
	// HealthCheck provides a health check endpoint
	HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error)
}

type metricsStreamClient struct {
	cc grpc.ClientConnInterface
}

func NewMetricsStreamClient(cc grpc.ClientConnInterface) MetricsStreamClient {
	return &metricsStreamClient{cc}
}

func (c *metricsStreamClient) StreamLatencyMetrics(ctx context.Context, opts ...grpc.CallOption) (MetricsStream_StreamLatencyMetricsClient, error) {
	stream, err := c.cc.NewStream(ctx, &MetricsStream_ServiceDesc.Streams[0], "/metrics.MetricsStream/StreamLatencyMetrics", opts...)
	if err != nil {
		return nil, err
	}
	x := &metricsStreamStreamLatencyMetricsClient{stream}
	return x, nil
}

type MetricsStream_StreamLatencyMetricsClient interface {
	Send(*LatencyMetric) error
	Recv() (*Ack, error)
	grpc.ClientStream
}

type metricsStreamStreamLatencyMetricsClient struct {
	grpc.ClientStream
}

func (x *metricsStreamStreamLatencyMetricsClient) Send(m *LatencyMetric) error {
	return x.ClientStream.SendMsg(m)
}

func (x *metricsStreamStreamLatencyMetricsClient) Recv() (*Ack, error) {
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metricsStreamClient) StreamConnectionEvents(ctx context.Context, opts ...grpc.CallOption) (MetricsStream_StreamConnectionEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &MetricsStream_ServiceDesc.Streams[1], "/metrics.MetricsStream/StreamConnectionEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &metricsStreamStreamConnectionEventsClient{stream}
	return x, nil
}

type MetricsStream_StreamConnectionEventsClient interface {
	Send(*ConnectionEvent) error
	Recv() (*Ack, error)
	grpc.ClientStream
}

type metricsStreamStreamConnectionEventsClient struct {
	grpc.ClientStream
}

func (x *metricsStreamStreamConnectionEventsClient) Send(m *ConnectionEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *metricsStreamStreamConnectionEventsClient) Recv() (*Ack, error) {
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metricsStreamClient) StreamFlowEvents(ctx context.Context, opts ...grpc.CallOption) (MetricsStream_StreamFlowEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &MetricsStream_ServiceDesc.Streams[2], "/metrics.MetricsStream/StreamFlowEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &metricsStreamStreamFlowEventsClient{stream}
	return x, nil
}

type MetricsStream_StreamFlowEventsClient interface {
	Send(*FlowEvent) error
	Recv() (*Ack, error)
	grpc.ClientStream
}

type metricsStreamStreamFlowEventsClient struct {
	grpc.ClientStream
}

func (x *metricsStreamStreamFlowEventsClient) Send(m *FlowEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *metricsStreamStreamFlowEventsClient) Recv() (*Ack, error) {
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metricsStreamClient) StreamDependencyEvents(ctx context.Context, opts ...grpc.CallOption) (MetricsStream_StreamDependencyEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &MetricsStream_ServiceDesc.Streams[3], "/metrics.MetricsStream/StreamDependencyEvents", opts...)
	if err != nil {
		return nil, err
	}
	x := &metricsStreamStreamDependencyEventsClient{stream}
	return x, nil
}

type MetricsStream_StreamDependencyEventsClient interface {
	Send(*DependencyEvent) error
	Recv() (*Ack, error)
	grpc.ClientStream
}

type metricsStreamStreamDependencyEventsClient struct {
	grpc.ClientStream
}

func (x *metricsStreamStreamDependencyEventsClient) Send(m *DependencyEvent) error {
	return x.ClientStream.SendMsg(m)
}

func (x *metricsStreamStreamDependencyEventsClient) Recv() (*Ack, error) {
	m := new(Ack)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *metricsStreamClient) HealthCheck(ctx context.Context, in *HealthCheckRequest, opts ...grpc.CallOption) (*HealthCheckResponse, error) {
	out := new(HealthCheckResponse)
	err := c.cc.Invoke(ctx, "/metrics.MetricsStream/HealthCheck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetricsStreamServer is the server API for MetricsStream service.
// All implementations must embed UnimplementedMetricsStreamServer
// for forward compatibility
type MetricsStreamServer interface {
	// StreamLatencyMetrics streams latency measurements (client-side streaming)
	StreamLatencyMetrics(MetricsStream_StreamLatencyMetricsServer) error
	// StreamConnectionEvents streams connection establishment events (client-side streaming)
	StreamConnectionEvents(MetricsStream_StreamConnectionEventsServer) error
	// StreamFlowEvents streams network flow events for dependency tracking
	StreamFlowEvents(MetricsStream_StreamFlowEventsServer) error
	// StreamDependencyEvents streams dependency relationship changes
	StreamDependencyEvents(MetricsStream_StreamDependencyEventsServer) error
	// HealthCheck provides a health check endpoint
	HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error)
	mustEmbedUnimplementedMetricsStreamServer()
}

// UnimplementedMetricsStreamServer must be embedded to have forward compatible implementations.
type UnimplementedMetricsStreamServer struct {
}

func (UnimplementedMetricsStreamServer) StreamLatencyMetrics(MetricsStream_StreamLatencyMetricsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamLatencyMetrics not implemented")
}
func (UnimplementedMetricsStreamServer) StreamConnectionEvents(MetricsStream_StreamConnectionEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamConnectionEvents not implemented")
}
func (UnimplementedMetricsStreamServer) StreamFlowEvents(MetricsStream_StreamFlowEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamFlowEvents not implemented")
}
func (UnimplementedMetricsStreamServer) StreamDependencyEvents(MetricsStream_StreamDependencyEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamDependencyEvents not implemented")
}
func (UnimplementedMetricsStreamServer) HealthCheck(context.Context, *HealthCheckRequest) (*HealthCheckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedMetricsStreamServer) mustEmbedUnimplementedMetricsStreamServer() {}

// UnsafeMetricsStreamServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MetricsStreamServer will
// result in compilation errors.
type UnsafeMetricsStreamServer interface {
	mustEmbedUnimplementedMetricsStreamServer()
}

func RegisterMetricsStreamServer(s grpc.ServiceRegistrar, srv MetricsStreamServer) {
	s.RegisterService(&MetricsStream_ServiceDesc, srv)
}

func _MetricsStream_StreamLatencyMetrics_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MetricsStreamServer).StreamLatencyMetrics(&metricsStreamStreamLatencyMetricsServer{stream})
}

type MetricsStream_StreamLatencyMetricsServer interface {
	Send(*Ack) error
	Recv() (*LatencyMetric, error)
	grpc.ServerStream
}

type metricsStreamStreamLatencyMetricsServer struct {
	grpc.ServerStream
}

func (x *metricsStreamStreamLatencyMetricsServer) Send(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *metricsStreamStreamLatencyMetricsServer) Recv() (*LatencyMetric, error) {
	m := new(LatencyMetric)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MetricsStream_StreamConnectionEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MetricsStreamServer).StreamConnectionEvents(&metricsStreamStreamConnectionEventsServer{stream})
}

type MetricsStream_StreamConnectionEventsServer interface {
	Send(*Ack) error
	Recv() (*ConnectionEvent, error)
	grpc.ServerStream
}

type metricsStreamStreamConnectionEventsServer struct {
	grpc.ServerStream
}

func (x *metricsStreamStreamConnectionEventsServer) Send(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *metricsStreamStreamConnectionEventsServer) Recv() (*ConnectionEvent, error) {
	m := new(ConnectionEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MetricsStream_StreamFlowEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MetricsStreamServer).StreamFlowEvents(&metricsStreamStreamFlowEventsServer{stream})
}

type MetricsStream_StreamFlowEventsServer interface {
	Send(*Ack) error
	Recv() (*FlowEvent, error)
	grpc.ServerStream
}

type metricsStreamStreamFlowEventsServer struct {
	grpc.ServerStream
}

func (x *metricsStreamStreamFlowEventsServer) Send(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *metricsStreamStreamFlowEventsServer) Recv() (*FlowEvent, error) {
	m := new(FlowEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MetricsStream_StreamDependencyEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MetricsStreamServer).StreamDependencyEvents(&metricsStreamStreamDependencyEventsServer{stream})
}

type MetricsStream_StreamDependencyEventsServer interface {
	Send(*Ack) error
	Recv() (*DependencyEvent, error)
	grpc.ServerStream
}

type metricsStreamStreamDependencyEventsServer struct {
	grpc.ServerStream
}

func (x *metricsStreamStreamDependencyEventsServer) Send(m *Ack) error {
	return x.ServerStream.SendMsg(m)
}

func (x *metricsStreamStreamDependencyEventsServer) Recv() (*DependencyEvent, error) {
	m := new(DependencyEvent)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MetricsStream_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetricsStreamServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metrics.MetricsStream/HealthCheck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetricsStreamServer).HealthCheck(ctx, req.(*HealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MetricsStream_ServiceDesc is the grpc.ServiceDesc for MetricsStream service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MetricsStream_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "metrics.MetricsStream",
	HandlerType: (*MetricsStreamServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HealthCheck",
			Handler:    _MetricsStream_HealthCheck_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamLatencyMetrics",
			Handler:       _MetricsStream_StreamLatencyMetrics_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamConnectionEvents",
			Handler:       _MetricsStream_StreamConnectionEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamFlowEvents",
			Handler:       _MetricsStream_StreamFlowEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamDependencyEvents",
			Handler:       _MetricsStream_StreamDependencyEvents_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pkg/proto/metrics.proto",
}

// DependencyGraphServiceClient is the client API for DependencyGraphService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DependencyGraphServiceClient interface {
	// GetDependencyGraph returns the current complete dependency graph
	GetDependencyGraph(ctx context.Context, in *DependencyGraphRequest, opts ...grpc.CallOption) (*DependencyGraph, error)
	// GetServices returns all discovered services
	GetServices(ctx context.Context, in *ServicesRequest, opts ...grpc.CallOption) (*ServicesResponse, error)
	// GetDependencies returns dependencies for a specific service or all dependencies
	GetDependencies(ctx context.Context, in *DependenciesRequest, opts ...grpc.CallOption) (*DependenciesResponse, error)
	// StreamDependencyUpdates provides real-time dependency graph updates
	StreamDependencyUpdates(ctx context.Context, in *DependencyUpdatesRequest, opts ...grpc.CallOption) (DependencyGraphService_StreamDependencyUpdatesClient, error)
}

type dependencyGraphServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDependencyGraphServiceClient(cc grpc.ClientConnInterface) DependencyGraphServiceClient {
	return &dependencyGraphServiceClient{cc}
}

func (c *dependencyGraphServiceClient) GetDependencyGraph(ctx context.Context, in *DependencyGraphRequest, opts ...grpc.CallOption) (*DependencyGraph, error) {
	out := new(DependencyGraph)
	err := c.cc.Invoke(ctx, "/metrics.DependencyGraphService/GetDependencyGraph", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependencyGraphServiceClient) GetServices(ctx context.Context, in *ServicesRequest, opts ...grpc.CallOption) (*ServicesResponse, error) {
	out := new(ServicesResponse)
	err := c.cc.Invoke(ctx, "/metrics.DependencyGraphService/GetServices", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependencyGraphServiceClient) GetDependencies(ctx context.Context, in *DependenciesRequest, opts ...grpc.CallOption) (*DependenciesResponse, error) {
	out := new(DependenciesResponse)
	err := c.cc.Invoke(ctx, "/metrics.DependencyGraphService/GetDependencies", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dependencyGraphServiceClient) StreamDependencyUpdates(ctx context.Context, in *DependencyUpdatesRequest, opts ...grpc.CallOption) (DependencyGraphService_StreamDependencyUpdatesClient, error) {
	stream, err := c.cc.NewStream(ctx, &DependencyGraphService_ServiceDesc.Streams[0], "/metrics.DependencyGraphService/StreamDependencyUpdates", opts...)
	if err != nil {
		return nil, err
	}
	x := &dependencyGraphServiceStreamDependencyUpdatesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DependencyGraphService_StreamDependencyUpdatesClient interface {
	Recv() (*DependencyGraph, error)
	grpc.ClientStream
}

type dependencyGraphServiceStreamDependencyUpdatesClient struct {
	grpc.ClientStream
}

func (x *dependencyGraphServiceStreamDependencyUpdatesClient) Recv() (*DependencyGraph, error) {
	m := new(DependencyGraph)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DependencyGraphServiceServer is the server API for DependencyGraphService service.
// All implementations must embed UnimplementedDependencyGraphServiceServer
// for forward compatibility
type DependencyGraphServiceServer interface {
	// GetDependencyGraph returns the current complete dependency graph
	GetDependencyGraph(context.Context, *DependencyGraphRequest) (*DependencyGraph, error)
	// GetServices returns all discovered services
	GetServices(context.Context, *ServicesRequest) (*ServicesResponse, error)
	// GetDependencies returns dependencies for a specific service or all dependencies
	GetDependencies(context.Context, *DependenciesRequest) (*DependenciesResponse, error)
	// StreamDependencyUpdates provides real-time dependency graph updates
	StreamDependencyUpdates(*DependencyUpdatesRequest, DependencyGraphService_StreamDependencyUpdatesServer) error
	mustEmbedUnimplementedDependencyGraphServiceServer()
}

// UnimplementedDependencyGraphServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDependencyGraphServiceServer struct {
}

func (UnimplementedDependencyGraphServiceServer) GetDependencyGraph(context.Context, *DependencyGraphRequest) (*DependencyGraph, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDependencyGraph not implemented")
}
func (UnimplementedDependencyGraphServiceServer) GetServices(context.Context, *ServicesRequest) (*ServicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServices not implemented")
}
func (UnimplementedDependencyGraphServiceServer) GetDependencies(context.Context, *DependenciesRequest) (*DependenciesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDependencies not implemented")
}
func (UnimplementedDependencyGraphServiceServer) StreamDependencyUpdates(*DependencyUpdatesRequest, DependencyGraphService_StreamDependencyUpdatesServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamDependencyUpdates not implemented")
}
func (UnimplementedDependencyGraphServiceServer) mustEmbedUnimplementedDependencyGraphServiceServer() {
}

// UnsafeDependencyGraphServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DependencyGraphServiceServer will
// result in compilation errors.
type UnsafeDependencyGraphServiceServer interface {
	mustEmbedUnimplementedDependencyGraphServiceServer()
}

func RegisterDependencyGraphServiceServer(s grpc.ServiceRegistrar, srv DependencyGraphServiceServer) {
	s.RegisterService(&DependencyGraphService_ServiceDesc, srv)
}

func _DependencyGraphService_GetDependencyGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DependencyGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependencyGraphServiceServer).GetDependencyGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metrics.DependencyGraphService/GetDependencyGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependencyGraphServiceServer).GetDependencyGraph(ctx, req.(*DependencyGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DependencyGraphService_GetServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependencyGraphServiceServer).GetServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metrics.DependencyGraphService/GetServices",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependencyGraphServiceServer).GetServices(ctx, req.(*ServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DependencyGraphService_GetDependencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DependenciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DependencyGraphServiceServer).GetDependencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/metrics.DependencyGraphService/GetDependencies",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DependencyGraphServiceServer).GetDependencies(ctx, req.(*DependenciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DependencyGraphService_StreamDependencyUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DependencyUpdatesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DependencyGraphServiceServer).StreamDependencyUpdates(m, &dependencyGraphServiceStreamDependencyUpdatesServer{stream})
}

type DependencyGraphService_StreamDependencyUpdatesServer interface {
	Send(*DependencyGraph) error
	grpc.ServerStream
}

type dependencyGraphServiceStreamDependencyUpdatesServer struct {
	grpc.ServerStream
}

func (x *dependencyGraphServiceStreamDependencyUpdatesServer) Send(m *DependencyGraph) error {
	return x.ServerStream.SendMsg(m)
}

// DependencyGraphService_ServiceDesc is the grpc.ServiceDesc for DependencyGraphService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DependencyGraphService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "metrics.DependencyGraphService",
	HandlerType: (*DependencyGraphServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDependencyGraph",
			Handler:    _DependencyGraphService_GetDependencyGraph_Handler,
		},
		{
			MethodName: "GetServices",
			Handler:    _DependencyGraphService_GetServices_Handler,
		},
		{
			MethodName: "GetDependencies",
			Handler:    _DependencyGraphService_GetDependencies_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamDependencyUpdates",
			Handler:       _DependencyGraphService_StreamDependencyUpdates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/proto/metrics.proto",
}
